(function(o,r){typeof exports=="object"&&typeof module<"u"?r(exports,require("buffer")):typeof define=="function"&&define.amd?define(["exports","buffer"],r):(o=typeof globalThis<"u"?globalThis:o||self,r(o.letsdecrypt={},o.buffer))})(this,function(o,r){"use strict";var C=Object.defineProperty;var T=(o,r,m)=>r in o?C(o,r,{enumerable:!0,configurable:!0,writable:!0,value:m}):o[r]=m;var u=(o,r,m)=>T(o,typeof r!="symbol"?r+"":r,m);class m{constructor(e,t){u(this,"encryptedData");u(this,"metadata");this.encryptedData=e,this.metadata=t}serialize(){return JSON.stringify({data:this.encryptedData,metadata:this.metadata})}static deserialize(e){const t=JSON.parse(e);return new m(t.data,t.metadata)}getEncryptedData(){return this.encryptedData}getMetadata(){return this.metadata}}class h{static getPublicKeyUsages(){throw Error("Abstract static method getPublicKeyUsages has not been implemented.")}static getPrivateKeyUsages(){throw Error("Abstract static method getPrivateKeyUsages has not been implemented.")}static getKeyPairUsages(){throw Error("Abstract static method getKeyPairUsages has not been implemented.")}static getAlgorithm(){throw Error("Abstract static method getAlgorithm has not been implemented.")}static getKeyGenParams(e){throw Error("Abstract static method getKeyGenParams has not been implemented.")}static async unwrapKey(e,t){throw Error("Abstract static method unwrapKey has not been implemented.")}static async generateKeyFromPassphrase(e){const t=new TextEncoder,a=await crypto.subtle.importKey("raw",t.encode(e),"PBKDF2",!1,["deriveBits","deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:t.encode("salt"),iterations:1e5,hash:this.HASH},a,{name:this.SYMMETRIC_ALGORITHM,length:256},!0,["encrypt","decrypt"])}static async wrapPublicKey(e,t,a){return{wrappedKey:r.Buffer.from(await crypto.subtle.exportKey("spki",e)).toString("base64"),iv:r.Buffer.from(crypto.getRandomValues(new Uint8Array(12))).toString("base64"),format:"spki",algorithm:t,namedCurve:a}}static async wrapPrivateKey(e,t,a,s){const n=a===this.ECC_ALGORITHM?"jwk":"pkcs8",i=await crypto.subtle.exportKey(n,e),c=n==="jwk"?new TextEncoder().encode(JSON.stringify(i)):new Uint8Array(i),y=await this.generateKeyFromPassphrase(t),p=crypto.getRandomValues(new Uint8Array(12)),g=await crypto.subtle.encrypt({name:this.SYMMETRIC_ALGORITHM,iv:p},y,c);return{wrappedKey:r.Buffer.from(g).toString("base64"),iv:r.Buffer.from(p).toString("base64"),algorithm:a,format:n,namedCurve:s}}static async generateKeyPair(e){const t=this.getKeyGenParams(e),a=await crypto.subtle.generateKey(t,!0,this.getKeyPairUsages()),s=await this.wrapPrivateKey(a.privateKey,(e==null?void 0:e.passphrase)??"",t.name,t.namedCurve);return{publicKey:await this.wrapPublicKey(a.publicKey,t.name,t.namedCurve),privateKey:s}}static async hashKey(e){const t=await crypto.subtle.exportKey("spki",e),a=await crypto.subtle.digest(this.HASH,t);return r.Buffer.from(a).toString("hex")}static async importPrivateKey(e,t){const a=JSON.parse(e);return this.unwrapKey(a,t??"")}}u(h,"RSA_ALGORITHM","RSA-OAEP"),u(h,"ECC_ALGORITHM","ECDH"),u(h,"SYMMETRIC_ALGORITHM","AES-GCM"),u(h,"DEFAULT_RSA_LENGTH",2048),u(h,"HASH","SHA-256");class w extends h{static getPublicKeyUsages(){return["encrypt"]}static getPrivateKeyUsages(){return["decrypt"]}static getKeyPairUsages(){return["encrypt","decrypt"]}static getAlgorithm(){return"RSA-OAEP"}static getKeyGenParams(e){return{name:this.RSA_ALGORITHM,modulusLength:(e==null?void 0:e.rsaModulusLength)||this.DEFAULT_RSA_LENGTH,publicExponent:new Uint8Array([1,0,1]),hash:this.HASH}}static async unwrapKey(e,t){const a=await this.generateKeyFromPassphrase(t),s=r.Buffer.from(e.wrappedKey,"base64"),n=r.Buffer.from(e.iv,"base64"),i=await crypto.subtle.decrypt({name:this.SYMMETRIC_ALGORITHM,iv:n},a,s),c=e.format||"pkcs8",y=c==="jwk"?JSON.parse(new TextDecoder().decode(i)):i;return crypto.subtle.importKey(c,y,{name:this.RSA_ALGORITHM,hash:this.HASH},!0,this.getPrivateKeyUsages())}static async encrypt(e,t){const a=await crypto.subtle.generateKey({name:this.SYMMETRIC_ALGORITHM,length:256},!0,["encrypt","decrypt"]),s=crypto.getRandomValues(new Uint8Array(12)),n=new TextEncoder().encode(e),i=await crypto.subtle.encrypt({name:this.SYMMETRIC_ALGORITHM,iv:s},a,n),c=await crypto.subtle.exportKey("raw",a),y=await crypto.subtle.encrypt({name:this.RSA_ALGORITHM},t,c),p={algorithm:this.RSA_ALGORITHM,keyHash:await this.hashKey(t),iv:r.Buffer.from(s).toString("base64"),symmetricKey:r.Buffer.from(y).toString("base64")};return new m(r.Buffer.from(i).toString("base64"),p)}static async decrypt(e,t,a){const s=typeof e=="string"?m.deserialize(e):e;let n;typeof t=="string"?n=await this.importPrivateKey(t,a):"wrappedKey"in t?n=await this.unwrapKey(t,a??""):n=t;const i=s.getMetadata(),c=r.Buffer.from(i.symmetricKey,"base64"),y=await crypto.subtle.decrypt({name:this.RSA_ALGORITHM},n,c),p=await crypto.subtle.importKey("raw",y,{name:this.SYMMETRIC_ALGORITHM,length:256},!1,["decrypt"]),g=r.Buffer.from(s.getEncryptedData(),"base64"),R=r.Buffer.from(i.iv,"base64"),b=await crypto.subtle.decrypt({name:this.SYMMETRIC_ALGORITHM,iv:R},p,g);return new TextDecoder().decode(b)}}class K extends h{static getPublicKeyUsages(){return[]}static getPrivateKeyUsages(){return["deriveKey","deriveBits"]}static getKeyPairUsages(){return["deriveKey","deriveBits"]}static getAlgorithm(){return"ECDH"}static getKeyGenParams(e){return{name:this.ECC_ALGORITHM,namedCurve:(e==null?void 0:e.eccCurve)||this.DEFAULT_ECC_CURVE}}static async unwrapKey(e,t){const a=await this.generateKeyFromPassphrase(t),s=r.Buffer.from(e.wrappedKey,"base64"),n=r.Buffer.from(e.iv,"base64"),i=await crypto.subtle.decrypt({name:this.SYMMETRIC_ALGORITHM,iv:n},a,s),c=e.format||(e.algorithm===this.ECC_ALGORITHM?"jwk":"pkcs8"),y=c==="jwk"?JSON.parse(new TextDecoder().decode(i)):i,p={name:this.ECC_ALGORITHM,namedCurve:e.namedCurve};return crypto.subtle.importKey(c,y,p,!0,this.getPrivateKeyUsages())}static async encrypt(e,t){const a=t.algorithm,s=await crypto.subtle.generateKey({name:this.ECC_ALGORITHM,namedCurve:a.namedCurve},!0,["deriveKey","deriveBits"]),n=await crypto.subtle.deriveKey({name:this.ECC_ALGORITHM,public:t},s.privateKey,{name:this.SYMMETRIC_ALGORITHM,length:256},!1,["encrypt"]),i=crypto.getRandomValues(new Uint8Array(12)),c=new TextEncoder().encode(e),y=await crypto.subtle.encrypt({name:this.SYMMETRIC_ALGORITHM,iv:i},n,c),p=await crypto.subtle.exportKey("spki",s.publicKey),g={algorithm:this.ECC_ALGORITHM,keyHash:await this.hashKey(t),iv:r.Buffer.from(i).toString("base64"),symmetricKey:"",publicKey:r.Buffer.from(p).toString("base64"),namedCurve:a.namedCurve};return new m(r.Buffer.from(y).toString("base64"),g)}static async decrypt(e,t,a){const s=typeof e=="string"?m.deserialize(e):e;let n;typeof t=="string"?n=await this.importPrivateKey(t,a):"wrappedKey"in t?n=await this.unwrapKey(t,a??""):n=t;const i=await crypto.subtle.importKey("spki",r.Buffer.from(s.getMetadata().publicKey,"base64"),{name:this.ECC_ALGORITHM,namedCurve:s.getMetadata().namedCurve??this.DEFAULT_ECC_CURVE},!0,[]),c=await crypto.subtle.deriveKey({name:this.ECC_ALGORITHM,public:i},n,{name:this.SYMMETRIC_ALGORITHM,length:256},!1,["decrypt"]),y=r.Buffer.from(s.getEncryptedData(),"base64"),p=r.Buffer.from(s.getMetadata().iv,"base64"),g=await crypto.subtle.decrypt({name:this.SYMMETRIC_ALGORITHM,iv:p},c,y);return new TextDecoder().decode(g)}}u(K,"DEFAULT_ECC_CURVE","P-256");class A extends Error{constructor(e,...t){super(...t),this.name="UnhandledMatchError",this.message=`Unhandled match value of type ${typeof e} - ${e}`,Error.captureStackTrace(this,A)}}function M(d){throw d}const f=Symbol(),S=d=>M(new A(d)),l=(d,e,t=S)=>{const a=new Map,s=Array.isArray(e)?e:Object.entries(e).map(([i,c])=>[i,c]);for(const[...i]of s){const c=i.pop();for(const y of i.flat())a.has(y)||a.set(y,c)}a.has(f)||a.set(f,t);const n=a.get(d)??a.get(f);return typeof n=="function"?n(d):n};l.default=f;class E{static async generateKeyPair(e){return l((e==null?void 0:e.algorithm)??"RSA",[["RSA",()=>w.generateKeyPair(e)],["ECC",()=>K.generateKeyPair(e)]])}static async exportKeyPair(e){return{publicKey:JSON.stringify(e.publicKey),privateKey:JSON.stringify(e.privateKey)}}static async importPublicKey(e){const t=JSON.parse(e),{wrappedKey:a,algorithm:s,format:n,namedCurve:i}=t,c=l(s,[["RSA-OAEP",()=>w.getPublicKeyUsages()],["ECDH",()=>K.getPublicKeyUsages()]]),y=l(s,[["RSA-OAEP",()=>({name:s,hash:this.HASH})],["ECDH",()=>({name:s,namedCurve:i})]]),p=r.Buffer.from(a,"base64");return await crypto.subtle.importKey(n,p,y,!0,c)}static async encrypt(e,t){const a=typeof t=="string"?await this.importPublicKey(t):t;return l(a.algorithm.name,[["RSA-OAEP",async()=>w.encrypt(e,a)],["ECDH",async()=>K.encrypt(e,a)]])}static async decrypt(e,t,a){return typeof e=="string"&&(e=m.deserialize(e)),l(e.getMetadata().algorithm,[["RSA-OAEP",async()=>w.decrypt(e,t,a)],["ECDH",async()=>K.decrypt(e,t,a)]])}}u(E,"HASH","SHA-256"),o.AbstractCryptoService=h,o.CryptoService=E,o.Secret=m,Object.defineProperty(o,Symbol.toStringTag,{value:"Module"})});
