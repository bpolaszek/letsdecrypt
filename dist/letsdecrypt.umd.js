(function(p,s){typeof exports=="object"&&typeof module<"u"?s(exports,require("buffer")):typeof define=="function"&&define.amd?define(["exports","buffer"],s):(p=typeof globalThis<"u"?globalThis:p||self,s(p.letsdecrypt={},p.buffer))})(this,function(p,s){"use strict";const D="ECDH",E="AES-GCM",C="SHA-256",g=async e=>{const t=new TextEncoder,r=await crypto.subtle.importKey("raw",t.encode(e),"PBKDF2",!1,["deriveBits","deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:t.encode("salt"),iterations:1e5,hash:C},r,{name:E,length:256},!0,["encrypt","decrypt"])},S=async(e,t,r)=>({wrappedKey:s.Buffer.from(await crypto.subtle.exportKey("spki",e)).toString("base64"),iv:s.Buffer.from(crypto.getRandomValues(new Uint8Array(12))).toString("base64"),format:"spki",algorithm:t,namedCurve:r}),v=async(e,t,r,a)=>{const n=r===D?"jwk":"pkcs8",c=await crypto.subtle.exportKey(n,e),y=n==="jwk"?new TextEncoder().encode(JSON.stringify(c)):new Uint8Array(c),o=await g(t),i=crypto.getRandomValues(new Uint8Array(12)),m=await crypto.subtle.encrypt({name:E,iv:i},o,y);return{wrappedKey:s.Buffer.from(m).toString("base64"),iv:s.Buffer.from(i).toString("base64"),algorithm:r,format:n,namedCurve:a}},P=async e=>{const t=await crypto.subtle.exportKey("spki",e),r=await crypto.subtle.digest(C,t);return s.Buffer.from(r).toString("hex")},l="RSA-OAEP",K="AES-GCM",B="SHA-256",R=e=>({name:l,modulusLength:(e==null?void 0:e.rsaModulusLength)||2048,publicExponent:new Uint8Array([1,0,1]),hash:B}),f={getPublicKeyUsages(){return["encrypt"]},getPrivateKeyUsages(){return["decrypt"]},getKeyPairUsages(){return["encrypt","decrypt"]},getAlgorithm(){return"RSA-OAEP"},async generateKeyPair(e){const t=R(e),r=await crypto.subtle.generateKey(t,!0,this.getKeyPairUsages()),a=await v(r.privateKey,(e==null?void 0:e.passphrase)??"",t.name);return{publicKey:await S(r.publicKey,t.name),privateKey:a}},async unwrapKey(e,t){const r=await g(t),a=s.Buffer.from(e.wrappedKey,"base64"),n=s.Buffer.from(e.iv,"base64"),c=await crypto.subtle.decrypt({name:K,iv:n},r,a),y=e.format||"pkcs8",o=y==="jwk"?JSON.parse(new TextDecoder().decode(c)):c;return crypto.subtle.importKey(y,o,{name:l,hash:B},!0,this.getPrivateKeyUsages())},async importPrivateKey(e,t){const r=JSON.parse(e);return this.unwrapKey(r,t??"")},async encrypt(e,t){const r=await crypto.subtle.generateKey({name:K,length:256},!0,["encrypt","decrypt"]),a=crypto.getRandomValues(new Uint8Array(12)),n=new TextEncoder().encode(e),c=await crypto.subtle.encrypt({name:K,iv:a},r,n),y=await crypto.subtle.exportKey("raw",r),o=await crypto.subtle.encrypt({name:l},t,y),i={algorithm:l,keyHash:await P(t),iv:s.Buffer.from(a).toString("base64"),symmetricKey:s.Buffer.from(o).toString("base64")};return{encryptedData:s.Buffer.from(c).toString("base64"),metadata:i}},async decrypt(e,t,r){const a=typeof e=="string"?JSON.parse(e):e;let n;typeof t=="string"?n=await this.importPrivateKey(t,r):"wrappedKey"in t?n=await this.unwrapKey(t,r??""):n=t;const c=a.metadata,y=s.Buffer.from(c.symmetricKey,"base64"),o=await crypto.subtle.decrypt({name:l},n,y),i=await crypto.subtle.importKey("raw",o,{name:K,length:256},!1,["decrypt"]),m=s.Buffer.from(a.encryptedData,"base64"),x=s.Buffer.from(c.iv,"base64"),G=await crypto.subtle.decrypt({name:K,iv:x},i,m);return new TextDecoder().decode(G)}},u="ECDH",H="P-256",w="AES-GCM",T=e=>({name:u,namedCurve:(e==null?void 0:e.eccCurve)||H}),h={getPublicKeyUsages(){return[]},getPrivateKeyUsages(){return["deriveKey","deriveBits"]},getKeyPairUsages(){return["deriveKey","deriveBits"]},getAlgorithm(){return"ECDH"},async generateKeyPair(e){const t=T(e),r=await crypto.subtle.generateKey(t,!0,this.getKeyPairUsages()),a=await v(r.privateKey,(e==null?void 0:e.passphrase)??"",t.name,t.namedCurve);return{publicKey:await S(r.publicKey,t.name,t.namedCurve),privateKey:a}},async importPrivateKey(e,t){const r=JSON.parse(e);return this.unwrapKey(r,t??"")},async unwrapKey(e,t){const r=await g(t),a=s.Buffer.from(e.wrappedKey,"base64"),n=s.Buffer.from(e.iv,"base64"),c=await crypto.subtle.decrypt({name:w,iv:n},r,a),y=e.format||(e.algorithm===u?"jwk":"pkcs8"),o=y==="jwk"?JSON.parse(new TextDecoder().decode(c)):c,i={name:u,namedCurve:e.namedCurve};return crypto.subtle.importKey(y,o,i,!0,this.getPrivateKeyUsages())},async encrypt(e,t){const r=t.algorithm,a=await crypto.subtle.generateKey({name:u,namedCurve:r.namedCurve},!0,["deriveKey","deriveBits"]),n=await crypto.subtle.deriveKey({name:u,public:t},a.privateKey,{name:w,length:256},!1,["encrypt"]),c=crypto.getRandomValues(new Uint8Array(12)),y=new TextEncoder().encode(e),o=await crypto.subtle.encrypt({name:w,iv:c},n,y),i=await crypto.subtle.exportKey("spki",a.publicKey),m={algorithm:u,keyHash:await P(t),iv:s.Buffer.from(c).toString("base64"),symmetricKey:"",publicKey:s.Buffer.from(i).toString("base64"),namedCurve:r.namedCurve};return{encryptedData:s.Buffer.from(o).toString("base64"),metadata:m}},async decrypt(e,t,r){const a=typeof e=="string"?JSON.parse(e):e;let n;typeof t=="string"?n=await this.importPrivateKey(t,r):"wrappedKey"in t?n=await this.unwrapKey(t,r??""):n=t;const c=await crypto.subtle.importKey("spki",s.Buffer.from(a.metadata.publicKey,"base64"),{name:u,namedCurve:a.metadata.namedCurve??H},!0,[]),y=await crypto.subtle.deriveKey({name:u,public:c},n,{name:w,length:256},!1,["decrypt"]),o=s.Buffer.from(a.encryptedData,"base64"),i=s.Buffer.from(a.metadata.iv,"base64"),m=await crypto.subtle.decrypt({name:w,iv:i},y,o);return new TextDecoder().decode(m)}};class A extends Error{constructor(t,...r){super(...r),this.name="UnhandledMatchError",this.message=`Unhandled match value of type ${typeof t} - ${t}`,Error.captureStackTrace(this,A)}}function k(e){throw e}const b=Symbol(),U=e=>k(new A(e)),d=(e,t,r=U)=>{const a=new Map,n=Array.isArray(t)?t:Object.entries(t).map(([y,o])=>[y,o]);for(const[...y]of n){const o=y.pop();for(const i of y.flat())a.has(i)||a.set(i,o)}a.has(b)||a.set(b,r);const c=a.get(e)??a.get(b);return typeof c=="function"?c(e):c};d.default=b;const O="SHA-256",M={async generateKeyPair(e){return d((e==null?void 0:e.algorithm)??"RSA",[["RSA",()=>f.generateKeyPair(e)],["ECC",()=>h.generateKeyPair(e)]])},async exportKeyPair(e){return{publicKey:JSON.stringify(e.publicKey),privateKey:JSON.stringify(e.privateKey)}},async importPublicKey(e){const t=JSON.parse(e),{wrappedKey:r,algorithm:a,format:n,namedCurve:c}=t,y=d(a,[["RSA-OAEP",()=>f.getPublicKeyUsages()],["ECDH",()=>h.getPublicKeyUsages()]]),o=d(a,[["RSA-OAEP",()=>({name:a,hash:O})],["ECDH",()=>({name:a,namedCurve:c})]]),i=s.Buffer.from(r,"base64");return await crypto.subtle.importKey(n,i,o,!0,y)},async encrypt(e,t){const r=typeof t=="string"?await this.importPublicKey(t):t;return d(r.algorithm.name,[["RSA-OAEP",async()=>f.encrypt(e,r)],["ECDH",async()=>h.encrypt(e,r)]])},async decrypt(e,t,r){return typeof e=="string"&&(e=JSON.parse(e)),d(e.metadata.algorithm,[["RSA-OAEP",async()=>f.decrypt(e,t,r)],["ECDH",async()=>h.decrypt(e,t,r)]])}};p.CryptoService=M,p.HASHING_ALGORITHM=O,p.generateKeyFromPassphrase=g,p.hashKey=P,p.wrapPrivateKey=v,p.wrapPublicKey=S,Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})});
