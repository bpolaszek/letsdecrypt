(function(s,N){typeof exports=="object"&&typeof module<"u"?N(require("node:buffer")):typeof define=="function"&&define.amd?define(["node:buffer"],N):(s=typeof globalThis<"u"?globalThis:s||self,N(s.node_buffer))})(this,function(s){"use strict";function N(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var j,X;function ce(){if(X)return j;X=1;function e(n,o){var a=n;o.slice(0,-1).forEach(function(y){a=a[y]||{}});var c=o[o.length-1];return c in a}function t(n){return typeof n=="number"||/^0x[0-9a-f]+$/i.test(n)?!0:/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(n)}function r(n,o){return o==="constructor"&&typeof n[o]=="function"||o==="__proto__"}return j=function(n,o){o||(o={});var a={bools:{},strings:{},unknownFn:null};typeof o.unknown=="function"&&(a.unknownFn=o.unknown),typeof o.boolean=="boolean"&&o.boolean?a.allBools=!0:[].concat(o.boolean).filter(Boolean).forEach(function(i){a.bools[i]=!0});var c={};function y(i){return c[i].some(function(d){return a.bools[d]})}Object.keys(o.alias||{}).forEach(function(i){c[i]=[].concat(o.alias[i]),c[i].forEach(function(d){c[d]=[i].concat(c[i].filter(function(P){return d!==P}))})}),[].concat(o.string).filter(Boolean).forEach(function(i){a.strings[i]=!0,c[i]&&[].concat(c[i]).forEach(function(d){a.strings[d]=!0})});var f=o.default||{},m={_:[]};function O(i,d){return a.allBools&&/^--[^=]+$/.test(d)||a.strings[i]||a.bools[i]||c[i]}function H(i,d,P){for(var p=i,I=0;I<d.length-1;I++){var g=d[I];if(r(p,g))return;p[g]===void 0&&(p[g]={}),(p[g]===Object.prototype||p[g]===Number.prototype||p[g]===String.prototype)&&(p[g]={}),p[g]===Array.prototype&&(p[g]=[]),p=p[g]}var A=d[d.length-1];r(p,A)||((p===Object.prototype||p===Number.prototype||p===String.prototype)&&(p={}),p===Array.prototype&&(p=[]),p[A]===void 0||a.bools[A]||typeof p[A]=="boolean"?p[A]=P:Array.isArray(p[A])?p[A].push(P):p[A]=[p[A],P])}function w(i,d,P){if(!(P&&a.unknownFn&&!O(i,P)&&a.unknownFn(P)===!1)){var p=!a.strings[i]&&t(d)?Number(d):d;H(m,i.split("."),p),(c[i]||[]).forEach(function(I){H(m,I.split("."),p)})}}Object.keys(a.bools).forEach(function(i){w(i,f[i]===void 0?!1:f[i])});var _=[];n.indexOf("--")!==-1&&(_=n.slice(n.indexOf("--")+1),n=n.slice(0,n.indexOf("--")));for(var K=0;K<n.length;K++){var u=n[K],l,h;if(/^--.+=/.test(u)){var oe=u.match(/^--([^=]+)=([\s\S]*)$/);l=oe[1];var Q=oe[2];a.bools[l]&&(Q=Q!=="false"),w(l,Q,u)}else if(/^--no-.+/.test(u))l=u.match(/^--no-(.+)/)[1],w(l,!1,u);else if(/^--.+/.test(u))l=u.match(/^--(.+)/)[1],h=n[K+1],h!==void 0&&!/^(-|--)[^-]/.test(h)&&!a.bools[l]&&!a.allBools&&(!c[l]||!y(l))?(w(l,h,u),K+=1):/^(true|false)$/.test(h)?(w(l,h==="true",u),K+=1):w(l,a.strings[l]?"":!0,u);else if(/^-[^-]+/.test(u)){for(var v=u.slice(1,-1).split(""),$=!1,b=0;b<v.length;b++){if(h=u.slice(b+2),h==="-"){w(v[b],h,u);continue}if(/[A-Za-z]/.test(v[b])&&h[0]==="="){w(v[b],h.slice(1),u),$=!0;break}if(/[A-Za-z]/.test(v[b])&&/-?\d+(\.\d*)?(e-?\d+)?$/.test(h)){w(v[b],h,u),$=!0;break}if(v[b+1]&&v[b+1].match(/\W/)){w(v[b],u.slice(b+2),u),$=!0;break}else w(v[b],a.strings[v[b]]?"":!0,u)}l=u.slice(-1)[0],!$&&l!=="-"&&(n[K+1]&&!/^(-|--)[^-]/.test(n[K+1])&&!a.bools[l]&&(!c[l]||!y(l))?(w(l,n[K+1],u),K+=1):n[K+1]&&/^(true|false)$/.test(n[K+1])?(w(l,n[K+1]==="true",u),K+=1):w(l,a.strings[l]?"":!0,u))}else if((!a.unknownFn||a.unknownFn(u)!==!1)&&m._.push(a.strings._||!t(u)?u:Number(u)),o.stopEarly){m._.push.apply(m._,n.slice(K+1));break}}return Object.keys(f).forEach(function(i){e(m,i.split("."))||(H(m,i.split("."),f[i]),(c[i]||[]).forEach(function(d){H(m,d.split("."),f[i])}))}),o["--"]?m["--"]=_.slice():_.forEach(function(i){m._.push(i)}),m},j}var ie=ce();const se=N(ie);class z extends Error{constructor(t,...r){super(...r),this.name="UnhandledMatchError",this.message=`Unhandled match value of type ${typeof t} - ${t}`,Error.captureStackTrace(this,z)}}function ye(e){throw e}const F=Symbol(),ue=e=>ye(new z(e)),E=(e,t,r=ue)=>{const n=new Map,o=Array.isArray(t)?t:Object.entries(t).map(([c,y])=>[c,y]);for(const[...c]of o){const y=c.pop();for(const f of c.flat())n.has(f)||n.set(f,y)}n.has(F)||n.set(F,r);const a=n.get(e)??n.get(F);return typeof a=="function"?a(e):a};E.default=F;const ee="AES-GCM",te="SHA-256",L=async e=>{const t=new TextEncoder,r=await crypto.subtle.importKey("raw",t.encode(e),"PBKDF2",!1,["deriveBits","deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:t.encode("salt"),iterations:1e5,hash:te},r,{name:ee,length:256},!0,["encrypt","decrypt"])},q=async(e,t,r,n)=>{if(e.type==="private")throw new Error("Cannot wrap a private key as public key");return{fingerprint:r,wrappedKey:s.Buffer.from(await crypto.subtle.exportKey("spki",e)).toString("base64"),iv:s.Buffer.from(crypto.getRandomValues(new Uint8Array(12))).toString("base64"),format:"spki",algorithm:t,namedCurve:n}},V=async(e,t,r,n,o)=>{const a="jwk",c=await crypto.subtle.exportKey(a,e),y=new TextEncoder().encode(JSON.stringify(c)),f=await L(t),m=crypto.getRandomValues(new Uint8Array(12)),O=await crypto.subtle.encrypt({name:ee,iv:m},f,y);return{fingerprint:n,wrappedKey:s.Buffer.from(O).toString("base64"),iv:s.Buffer.from(m).toString("base64"),algorithm:r,format:a,namedCurve:o,protected:t.length>0?!0:void 0}},B=async(e,t="spki")=>{const r=await crypto.subtle.exportKey(t,e),n=await crypto.subtle.digest(te,r);return s.Buffer.from(n).toString("hex")},T="RSA-OAEP",x="AES-GCM",pe=2048,U="SHA-256",fe=e=>({name:T,modulusLength:(e==null?void 0:e.rsaModulusLength)||pe,publicExponent:new Uint8Array([1,0,1]),hash:U}),R={async generateKeyPair(e){const t=fe(e),r=await crypto.subtle.generateKey(t,!0,["encrypt","decrypt"]),n=await B(r.publicKey),o=await V(r.privateKey,(e==null?void 0:e.passphrase)??"",t.name,n);return{publicKey:await q(r.publicKey,t.name,n),privateKey:o,fingerprint:n}},async importPublicKey(e){if(e instanceof CryptoKey)return e;const t=typeof e=="string"?C(e):e,{wrappedKey:r,algorithm:n,format:o}=t,a={name:n,hash:U},c=s.Buffer.from(r,"base64");return await crypto.subtle.importKey(o,c,a,!0,["encrypt"])},async importPrivateKey(e,t){if(e instanceof CryptoKey)return e;const r=typeof e=="string"?C(e):e,n=await L(t),o=s.Buffer.from(r.wrappedKey,"base64"),a=s.Buffer.from(r.iv,"base64"),c=await crypto.subtle.decrypt({name:x,iv:a},n,o),y=r.format||"pkcs8",f=y==="jwk"?JSON.parse(new TextDecoder().decode(c)):c;return crypto.subtle.importKey(y,f,{name:T,hash:U},!0,["decrypt"])},async derivePublicKey(e){const t=await crypto.subtle.exportKey("jwk",e),r={kty:t.kty,n:t.n,e:t.e,alg:t.alg,ext:!0};return crypto.subtle.importKey("jwk",r,{name:T,hash:U},!0,["encrypt"])},async encrypt(e,t){t=await this.importPublicKey(t);const r=await crypto.subtle.generateKey({name:x,length:256},!0,["encrypt","decrypt"]),n=crypto.getRandomValues(new Uint8Array(12)),o=new TextEncoder().encode(e),a=await crypto.subtle.encrypt({name:x,iv:n},r,o),c=await crypto.subtle.exportKey("raw",r),y=await crypto.subtle.encrypt({name:T},t,c),f={algorithm:T,keyFingerprint:await B(t),iv:s.Buffer.from(n).toString("base64"),symmetricKey:s.Buffer.from(y).toString("base64")};return{encryptedData:s.Buffer.from(a).toString("base64"),metadata:f}},async decrypt(e,t,r){const n=typeof e=="string"?Z(e):e;t=await this.importPrivateKey(t,r??"");const o=n.metadata,a=s.Buffer.from(o.symmetricKey,"base64"),c=await crypto.subtle.decrypt({name:T},t,a),y=await crypto.subtle.importKey("raw",c,{name:x,length:256},!1,["decrypt"]),f=s.Buffer.from(n.encryptedData,"base64"),m=s.Buffer.from(o.iv,"base64"),O=await crypto.subtle.decrypt({name:x,iv:m},y,f);return new TextDecoder().decode(O)}},S="ECDH",re="P-256",G="AES-GCM",me=e=>({name:S,namedCurve:(e==null?void 0:e.eccCurve)||re}),D={async generateKeyPair(e){const t=me(e),r=await crypto.subtle.generateKey(t,!0,["deriveKey","deriveBits"]),n=await B(r.publicKey),o=await V(r.privateKey,(e==null?void 0:e.passphrase)??"",t.name,n,t.namedCurve);return{publicKey:await q(r.publicKey,t.name,n,t.namedCurve),privateKey:o,fingerprint:n}},async importPrivateKey(e,t){if(e instanceof CryptoKey)return e;const r=typeof e=="string"?C(e):e,n=await L(t),o=s.Buffer.from(r.wrappedKey,"base64"),a=s.Buffer.from(r.iv,"base64"),c=await crypto.subtle.decrypt({name:G,iv:a},n,o),y=r.format||(r.algorithm===S?"jwk":"pkcs8"),f=y==="jwk"?JSON.parse(new TextDecoder().decode(c)):c,m={name:S,namedCurve:r.namedCurve};return crypto.subtle.importKey(y,f,m,!0,["deriveKey","deriveBits"])},async derivePublicKey(e){const t=await crypto.subtle.exportKey("jwk",e),r={kty:t.kty,crv:t.crv,x:t.x,y:t.y,ext:!0};return crypto.subtle.importKey("jwk",r,{name:S,namedCurve:e.algorithm.namedCurve},!0,[])},async importPublicKey(e){if(e instanceof CryptoKey)return e;const t=typeof e=="string"?C(e):e,{wrappedKey:r,algorithm:n,format:o,namedCurve:a}=t,c={name:n,namedCurve:a},y=s.Buffer.from(r,"base64");return await crypto.subtle.importKey(o,y,c,!0,[])},async encrypt(e,t){t=await this.importPublicKey(t);const r=t.algorithm,n=await crypto.subtle.generateKey({name:S,namedCurve:r.namedCurve},!0,["deriveKey","deriveBits"]),o=await crypto.subtle.deriveKey({name:S,public:t},n.privateKey,{name:G,length:256},!1,["encrypt"]),a=crypto.getRandomValues(new Uint8Array(12)),c=new TextEncoder().encode(e),y=await crypto.subtle.encrypt({name:G,iv:a},o,c),f=await crypto.subtle.exportKey("spki",n.publicKey),m={algorithm:S,keyFingerprint:await B(t),iv:s.Buffer.from(a).toString("base64"),symmetricKey:"",publicKey:s.Buffer.from(f).toString("base64"),namedCurve:r.namedCurve};return{encryptedData:s.Buffer.from(y).toString("base64"),metadata:m}},async decrypt(e,t,r){const n=typeof e=="string"?Z(e):e;t=await this.importPrivateKey(t,r??"");const o=await crypto.subtle.importKey("spki",s.Buffer.from(n.metadata.publicKey,"base64"),{name:S,namedCurve:n.metadata.namedCurve??re},!0,[]),a=await crypto.subtle.deriveKey({name:S,public:o},t,{name:G,length:256},!1,["decrypt"]),c=s.Buffer.from(n.encryptedData,"base64"),y=s.Buffer.from(n.metadata.iv,"base64"),f=await crypto.subtle.decrypt({name:G,iv:y},a,c);return new TextDecoder().decode(f)}},J="AES-CTR",le="AES-GCM",ne={name:J,length:256},M={async generateKeyPair(e){const t=await crypto.subtle.generateKey(ne,!0,["encrypt","decrypt"]),r=await B(t,"raw"),n=(e==null?void 0:e.passphrase)||"",o={fingerprint:r,wrappedKey:s.Buffer.from(JSON.stringify(await crypto.subtle.exportKey("jwk",t))).toString("base64"),algorithm:J,format:"jwk"},a=n.length>0?await V(t,n,J,r):o;return{publicKey:o,privateKey:a,fingerprint:r}},derivePublicKey(){throw Error("Not implemented")},async importPublicKey(e){return this.importPrivateKey(e,"")},async importPrivateKey(e,t){if(e instanceof CryptoKey)return e;const r=typeof e=="string"?C(e):e,{wrappedKey:n,format:o,iv:a,protected:c}=r,y=ne;if(c){const O=await L(t),H=await crypto.subtle.decrypt({name:le,iv:s.Buffer.from(a,"base64")},O,s.Buffer.from(n,"base64")),w=JSON.parse(new TextDecoder().decode(H));return await crypto.subtle.importKey(o,w,y,!0,["encrypt","decrypt"])}const f=s.Buffer.from(n,"base64").toString(),m=JSON.parse(f);return await crypto.subtle.importKey(o,m,y,!0,["encrypt","decrypt"])},async encrypt(e,t){t=await this.importPublicKey(t);const r=new TextEncoder().encode(e),n={name:"AES-CTR",counter:new Uint8Array(16),length:16*8},o=await crypto.subtle.encrypt(n,t,r),a={algorithm:J,keyFingerprint:await B(t,"raw")};return{encryptedData:s.Buffer.from(o).toString("base64"),metadata:a}},async decrypt(e,t,r){const n=typeof e=="string"?Z(e):e;t=await this.importPrivateKey(t,r??"");const o={name:"AES-CTR",counter:new Uint8Array(16),length:16*8};return new TextDecoder("utf-8").decode(await crypto.subtle.decrypt(o,t,s.Buffer.from(n.encryptedData,"base64")))}};function ae(e){return btoa(encodeURIComponent(e))}function k(e){return decodeURIComponent(atob(e))}const de=async e=>{let t;if(typeof e=="string")t=C(e);else if(typeof e=="object")t=e;else return e;return E(t.algorithm,[["RSA-OAEP",()=>R.importPublicKey(t)],["ECDH",()=>D.importPublicKey(t)],["AES-CTR",()=>M.importPublicKey(t)]])},we=async e=>E((e==null?void 0:e.algorithm)??"RSA",[["RSA",()=>R.generateKeyPair(e)],["ECC",()=>D.generateKeyPair(e)],["AES",()=>M.generateKeyPair(e)]]),Y=e=>ae(JSON.stringify(e)),C=e=>JSON.parse(k(e)),Ke=async e=>({publicKey:Y(e.publicKey),privateKey:Y(e.privateKey),fingerprint:e.fingerprint}),be=async(e,t)=>{const r=await de(t);return E(r.algorithm.name,[["RSA-OAEP",async()=>R.encrypt(e,r)],["ECDH",async()=>D.encrypt(e,r)],["AES-CTR",async()=>M.encrypt(e,r)]])},he=e=>ae(JSON.stringify(e)),Z=e=>JSON.parse(k(e)),ve=async(e,t,r)=>(typeof e=="string"&&(e=JSON.parse(k(e))),E(e.metadata.algorithm,[["RSA-OAEP",async()=>R.decrypt(e,t,r)],["ECDH",async()=>D.decrypt(e,t,r)],["AES-CTR",async()=>M.decrypt(e,t,r)]])),ge=async(e,t="")=>{const r=typeof e=="string"?C(e):e,n=await E(r.algorithm,[["RSA-OAEP",()=>R.importPrivateKey(r,t)],["ECDH",()=>D.importPrivateKey(r,t)],["AES-CTR",()=>M.importPrivateKey(r,t)]]);if(r.algorithm==="AES-CTR")return r;const o=await E(r.algorithm,[["RSA-OAEP",()=>R.derivePublicKey(n)],["ECDH",()=>D.derivePublicKey(n)],["AES-CTR",()=>M.derivePublicKey(n)]]);return q(o,r.algorithm,r.fingerprint,r.namedCurve)},Se=async(e,t)=>{const{privateKey:r}=await Ke(await we(t));return r},W=()=>{throw new Error("A required value was not provided")};async function Pe(e,t){const r=t["private-key"]??W();return Y(await ge(r,t.passphrase??""))}async function Ae([e],t){const r=t["public-key"]??W();return he(await be(e,r))}async function Ee([e],t){const r=t["private-key"]??W();return await ve(e,r,t.passphrase??"")}(async()=>{const e=se(process.argv.slice(2)),t=e._[0]??void 0;e._.shift();const r=e._,n=e;delete n._;const o=()=>E(t,[["private-key:generate",()=>Se(r,n)],["public-key:generate",()=>Pe(r,n)],["encrypt",()=>Ae(r,n)],["decrypt",()=>Ee(r,n)]]);try{console.log(await o()),process.exit(0)}catch(a){console.error(a),process.exit(1)}})()});
