(function(p,c){typeof exports=="object"&&typeof module<"u"?c(exports,require("buffer")):typeof define=="function"&&define.amd?define(["exports","buffer"],c):(p=typeof globalThis<"u"?globalThis:p||self,c(p.letsdecrypt={},p.buffer))})(this,function(p,c){"use strict";const T="AES-GCM",B="SHA-256",S=async e=>{const t=new TextEncoder,r=await crypto.subtle.importKey("raw",t.encode(e),"PBKDF2",!1,["deriveBits","deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:t.encode("salt"),iterations:1e5,hash:B},r,{name:T,length:256},!0,["encrypt","decrypt"])},R=async(e,t,r)=>({wrappedKey:c.Buffer.from(await crypto.subtle.exportKey("spki",e)).toString("base64"),iv:c.Buffer.from(crypto.getRandomValues(new Uint8Array(12))).toString("base64"),format:"spki",algorithm:t,namedCurve:r}),b=async(e,t,r,a)=>{const n="jwk",o=await crypto.subtle.exportKey(n,e),s=new TextEncoder().encode(JSON.stringify(o)),y=await S(t),i=crypto.getRandomValues(new Uint8Array(12)),m=await crypto.subtle.encrypt({name:T,iv:i},y,s);return{wrappedKey:c.Buffer.from(m).toString("base64"),iv:c.Buffer.from(i).toString("base64"),algorithm:r,format:n,namedCurve:a,protected:t.length>0?!0:void 0}},A=async(e,t="spki")=>{const r=await crypto.subtle.exportKey(t,e),a=await crypto.subtle.digest(B,r);return c.Buffer.from(a).toString("hex")},l="RSA-OAEP",K="AES-GCM",C="SHA-256",H=e=>({name:l,modulusLength:(e==null?void 0:e.rsaModulusLength)||2048,publicExponent:new Uint8Array([1,0,1]),hash:C}),f={async generateKeyPair(e){const t=H(e),r=await crypto.subtle.generateKey(t,!0,["encrypt","decrypt"]),a=await b(r.privateKey,(e==null?void 0:e.passphrase)??"",t.name);return{publicKey:await R(r.publicKey,t.name),privateKey:a}},async importPublicKey(e){if(e instanceof CryptoKey)return e;const t=typeof e=="string"?JSON.parse(e):e,{wrappedKey:r,algorithm:a,format:n}=t,o={name:a,hash:C},s=c.Buffer.from(r,"base64");return await crypto.subtle.importKey(n,s,o,!0,["encrypt"])},async importPrivateKey(e,t){if(e instanceof CryptoKey)return e;const r=typeof e=="string"?JSON.parse(e):e,a=await S(t),n=c.Buffer.from(r.wrappedKey,"base64"),o=c.Buffer.from(r.iv,"base64"),s=await crypto.subtle.decrypt({name:K,iv:o},a,n),y=r.format||"pkcs8",i=y==="jwk"?JSON.parse(new TextDecoder().decode(s)):s;return crypto.subtle.importKey(y,i,{name:l,hash:C},!0,["decrypt"])},async encrypt(e,t){t=await this.importPublicKey(t);const r=await crypto.subtle.generateKey({name:K,length:256},!0,["encrypt","decrypt"]),a=crypto.getRandomValues(new Uint8Array(12)),n=new TextEncoder().encode(e),o=await crypto.subtle.encrypt({name:K,iv:a},r,n),s=await crypto.subtle.exportKey("raw",r),y=await crypto.subtle.encrypt({name:l},t,s),i={algorithm:l,keyHash:await A(t),iv:c.Buffer.from(a).toString("base64"),symmetricKey:c.Buffer.from(y).toString("base64")};return{encryptedData:c.Buffer.from(o).toString("base64"),metadata:i}},async decrypt(e,t,r){const a=typeof e=="string"?JSON.parse(e):e;t=await this.importPrivateKey(t,r??"");const n=a.metadata,o=c.Buffer.from(n.symmetricKey,"base64"),s=await crypto.subtle.decrypt({name:l},t,o),y=await crypto.subtle.importKey("raw",s,{name:K,length:256},!1,["decrypt"]),i=c.Buffer.from(a.encryptedData,"base64"),m=c.Buffer.from(n.iv,"base64"),O=await crypto.subtle.decrypt({name:K,iv:m},y,i);return new TextDecoder().decode(O)}},d="ECDH",k="P-256",w="AES-GCM",M=e=>({name:d,namedCurve:(e==null?void 0:e.eccCurve)||k}),g={async generateKeyPair(e){const t=M(e),r=await crypto.subtle.generateKey(t,!0,["deriveKey","deriveBits"]),a=await b(r.privateKey,(e==null?void 0:e.passphrase)??"",t.name,t.namedCurve);return{publicKey:await R(r.publicKey,t.name,t.namedCurve),privateKey:a}},async importPrivateKey(e,t){if(e instanceof CryptoKey)return e;const r=typeof e=="string"?JSON.parse(e):e,a=await S(t),n=c.Buffer.from(r.wrappedKey,"base64"),o=c.Buffer.from(r.iv,"base64"),s=await crypto.subtle.decrypt({name:w,iv:o},a,n),y=r.format||(r.algorithm===d?"jwk":"pkcs8"),i=y==="jwk"?JSON.parse(new TextDecoder().decode(s)):s,m={name:d,namedCurve:r.namedCurve};return crypto.subtle.importKey(y,i,m,!0,["deriveKey","deriveBits"])},async importPublicKey(e){if(e instanceof CryptoKey)return e;const t=typeof e=="string"?JSON.parse(e):e,{wrappedKey:r,algorithm:a,format:n,namedCurve:o}=t,s={name:a,namedCurve:o},y=c.Buffer.from(r,"base64");return await crypto.subtle.importKey(n,y,s,!0,[])},async encrypt(e,t){t=await this.importPublicKey(t);const r=t.algorithm,a=await crypto.subtle.generateKey({name:d,namedCurve:r.namedCurve},!0,["deriveKey","deriveBits"]),n=await crypto.subtle.deriveKey({name:d,public:t},a.privateKey,{name:w,length:256},!1,["encrypt"]),o=crypto.getRandomValues(new Uint8Array(12)),s=new TextEncoder().encode(e),y=await crypto.subtle.encrypt({name:w,iv:o},n,s),i=await crypto.subtle.exportKey("spki",a.publicKey),m={algorithm:d,keyHash:await A(t),iv:c.Buffer.from(o).toString("base64"),symmetricKey:"",publicKey:c.Buffer.from(i).toString("base64"),namedCurve:r.namedCurve};return{encryptedData:c.Buffer.from(y).toString("base64"),metadata:m}},async decrypt(e,t,r){const a=typeof e=="string"?JSON.parse(e):e;t=await this.importPrivateKey(t,r??"");const n=await crypto.subtle.importKey("spki",c.Buffer.from(a.metadata.publicKey,"base64"),{name:d,namedCurve:a.metadata.namedCurve??k},!0,[]),o=await crypto.subtle.deriveKey({name:d,public:n},t,{name:w,length:256},!1,["decrypt"]),s=c.Buffer.from(a.encryptedData,"base64"),y=c.Buffer.from(a.metadata.iv,"base64"),i=await crypto.subtle.decrypt({name:w,iv:y},o,s);return new TextDecoder().decode(i)}},v="AES-CTR",x="AES-GCM",D={name:v,length:256},h={async generateKeyPair(e){const t=await crypto.subtle.generateKey(D,!0,["encrypt","decrypt"]),r=(e==null?void 0:e.passphrase)||"",a={wrappedKey:c.Buffer.from(JSON.stringify(await crypto.subtle.exportKey("jwk",t))).toString("base64"),algorithm:v,format:"jwk"},n=r.length>0?await b(t,r,v):a;return{publicKey:a,privateKey:n}},async importPublicKey(e){return this.importPrivateKey(e,"")},async importPrivateKey(e,t){if(e instanceof CryptoKey)return e;const r=typeof e=="string"?JSON.parse(e):e,{wrappedKey:a,format:n,iv:o,protected:s}=r,y=D;if(s){const O=await S(t),F=await crypto.subtle.decrypt({name:x,iv:c.Buffer.from(o,"base64")},O,c.Buffer.from(a,"base64")),V=JSON.parse(new TextDecoder().decode(F));return await crypto.subtle.importKey(n,V,y,!0,["encrypt","decrypt"])}const i=c.Buffer.from(a,"base64").toString(),m=JSON.parse(i);return await crypto.subtle.importKey(n,m,y,!0,["encrypt","decrypt"])},async encrypt(e,t){t=await this.importPublicKey(t);const r=new TextEncoder().encode(e),a={name:"AES-CTR",counter:new Uint8Array(16),length:16*8},n=await crypto.subtle.encrypt(a,t,r),o={algorithm:v,keyHash:await A(t,"raw")};return{encryptedData:c.Buffer.from(n).toString("base64"),metadata:o}},async decrypt(e,t,r){const a=typeof e=="string"?JSON.parse(e):e;t=await this.importPrivateKey(t,r??"");const n={name:"AES-CTR",counter:new Uint8Array(16),length:16*8};return new TextDecoder("utf-8").decode(await crypto.subtle.decrypt(n,t,c.Buffer.from(a.encryptedData,"base64")))}};class E extends Error{constructor(t,...r){super(...r),this.name="UnhandledMatchError",this.message=`Unhandled match value of type ${typeof t} - ${t}`,Error.captureStackTrace(this,E)}}function N(e){throw e}const P=Symbol(),G=e=>N(new E(e)),u=(e,t,r=G)=>{const a=new Map,n=Array.isArray(t)?t:Object.entries(t).map(([s,y])=>[s,y]);for(const[...s]of n){const y=s.pop();for(const i of s.flat())a.has(i)||a.set(i,y)}a.has(P)||a.set(P,r);const o=a.get(e)??a.get(P);return typeof o=="function"?o(e):o};u.default=P;const J=async e=>{let t;if(typeof e=="string")t=JSON.parse(e);else if(typeof e=="object")t=e;else return e;return u(t.algorithm,[["RSA-OAEP",()=>f.importPublicKey(t)],["ECDH",()=>g.importPublicKey(t)],["AES-CTR",()=>h.importPublicKey(t)]])},L=async(e,t,r)=>{const a=typeof e=="string"?JSON.parse(e):e,n=await u(a.algorithm,[["RSA-OAEP",()=>f.importPrivateKey(a,t??"")],["ECDH",()=>g.importPrivateKey(a,t??"")],["AES-CTR",()=>h.importPrivateKey(a,t??"")]]);return b(n,r??"",a.algorithm,a.namedCurve)},I=async e=>u((e==null?void 0:e.algorithm)??"RSA",[["RSA",()=>f.generateKeyPair(e)],["ECC",()=>g.generateKeyPair(e)],["AES",()=>h.generateKeyPair(e)]]),_=async e=>({publicKey:JSON.stringify(e.publicKey),privateKey:JSON.stringify(e.privateKey)}),j=async(e,t)=>{const r=await J(t);return u(r.algorithm.name,[["RSA-OAEP",async()=>f.encrypt(e,r)],["ECDH",async()=>g.encrypt(e,r)],["AES-CTR",async()=>h.encrypt(e,r)]])},U=async(e,t,r)=>(typeof e=="string"&&(e=JSON.parse(e)),u(e.metadata.algorithm,[["RSA-OAEP",async()=>f.decrypt(e,t,r)],["ECDH",async()=>g.decrypt(e,t,r)],["AES-CTR",async()=>h.decrypt(e,t,r)]]));p.changePassphrase=L,p.decrypt=U,p.encrypt=j,p.exportKeyPair=_,p.generateKeyPair=I,Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})});
